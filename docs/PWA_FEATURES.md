# Rewind PWA Features Specifications

## Overview

Rewind is designed as a mobile-first Progressive Web App (PWA) to provide a native app-like experience for podcast enthusiasts aged 35+. This document outlines the PWA features including offline functionality, app installation, background audio playback, and push notifications, ensuring seamless podcast discovery and playback across devices.

## ðŸš§ Current Implementation Status

### âœ… Phase 1 - Basic PWA Foundation (Completed)

- âœ… PWA manifest file configuration
- âœ… Basic service worker setup with Vite PWA plugin
- âœ… Mobile-first responsive design
- âœ… App shell architecture with React Router
- âœ… Basic offline capabilities for static assets

### ðŸ“‹ Phase 2 - Enhanced PWA Features (Next Sprint)

- ðŸ“‹ Advanced service worker for podcast caching
- ðŸ“‹ Background audio playback with Media Session API
- ðŸ“‹ App installation prompts and experience
- ðŸ“‹ Offline podcast metadata and library access

### ðŸ”® Phase 3 - Advanced PWA Features (Future)

- ðŸ”® Push notifications for new episodes
- ðŸ”® Background sync for podcast updates
- ðŸ”® Advanced offline audio caching strategies
- ðŸ”® App shortcuts and widgets

## Target PWA Experience

### Core PWA Requirements âœ… IMPLEMENTED

- **App Shell**: Instant loading with cached navigation and layout
- **Responsive Design**: Works seamlessly on mobile, tablet, and desktop
- **Offline First**: Core functionality available without internet
- **App-like Feel**: Native-style navigation and interactions

### User Experience Goals

- **Installation**: Users can install Rewind like a native app
- **Performance**: Sub-3-second load times on 3G networks
- **Reliability**: Works offline for previously accessed content
- **Engagement**: Push notifications for relevant content updates

## ðŸ“‹ Service Worker Implementation (Phase 2)

### Current Basic Service Worker âœ… IMPLEMENTED

```typescript
// Basic service worker generated by Vite PWA plugin
// Located in public/sw.js (auto-generated)

// Features currently implemented:
// - Static asset caching (app shell)
// - Runtime caching for API calls
// - Background update notifications
// - Basic offline fallbacks
```

### Enhanced Service Worker (Phase 2)

```typescript
// Advanced service worker for podcast-specific features
// src/sw.ts (custom implementation)

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies'
import { BackgroundSync } from 'workbox-background-sync'

// Precache app shell and static assets
precacheAndRoute(self.__WB_MANIFEST)
cleanupOutdatedCaches()

// Cache podcast metadata with network-first strategy
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/podcasts'),
  new NetworkFirst({
    cacheName: 'podcast-metadata',
    networkTimeoutSeconds: 3,
    plugins: [
      {
        cacheWillUpdate: async ({ response }) => {
          return response.status === 200 ? response : null
        },
      },
    ],
  }),
)

// Cache podcast images with cache-first strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'podcast-images',
    plugins: [
      {
        cacheableResponse: {
          statuses: [0, 200],
        },
      },
    ],
  }),
)

// Background sync for podcast updates
const bgSync = new BackgroundSync('podcast-updates', {
  maxRetentionTime: 24 * 60, // 24 hours
})

// Queue failed podcast additions for retry
registerRoute(
  ({ url }) => url.pathname === '/api/podcasts' && request.method === 'POST',
  new NetworkFirst({
    plugins: [bgSync],
  }),
)
```

### Audio Caching Strategy (Phase 3)

```typescript
// Advanced audio caching for offline playback
registerRoute(
  ({ request }) => request.destination === 'audio',
  new CacheFirst({
    cacheName: 'podcast-audio',
    plugins: [
      {
        cacheableResponse: {
          statuses: [200, 206], // Support range requests
        },
        rangeRequests: true, // Enable audio streaming
      },
    ],
  }),
)

// Intelligent audio pre-caching based on user preferences
self.addEventListener('message', event => {
  if (event.data.type === 'PRECACHE_EPISODE') {
    const { audioUrl, episodeId } = event.data.payload
    precacheEpisode(audioUrl, episodeId)
  }
})

async function precacheEpisode(audioUrl: string, episodeId: string) {
  try {
    const response = await fetch(audioUrl)
    const cache = await caches.open('podcast-audio')
    await cache.put(`/episode/${episodeId}/audio`, response)

    // Notify main thread of successful precaching
    self.clients.matchAll().then(clients => {
      clients.forEach(client => {
        client.postMessage({
          type: 'EPISODE_CACHED',
          payload: { episodeId, success: true },
        })
      })
    })
  } catch (error) {
    console.error('Failed to precache episode:', error)
  }
}
```

## App Manifest Configuration âœ… DEPLOYED

### Current Manifest (Basic)

```json
{
  "name": "Rewind - Rediscover Podcasts",
  "short_name": "Rewind",
  "description": "Rediscover your favorite podcast episodes with AI-powered recommendations",
  "theme_color": "#eb4034",
  "background_color": "#ffffff",
  "display": "standalone",
  "orientation": "portrait-primary",
  "scope": "/",
  "start_url": "/",
  "icons": [
    {
      "src": "/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

### Enhanced Manifest (Phase 2)

```json
{
  "name": "Rewind - Rediscover Podcasts",
  "short_name": "Rewind",
  "description": "Rediscover your favorite podcast episodes with AI-powered recommendations",
  "theme_color": "#eb4034",
  "background_color": "#ffffff",
  "display": "standalone",
  "orientation": "portrait-primary",
  "scope": "/",
  "start_url": "/",
  "categories": ["entertainment", "music", "news"],
  "lang": "en-US",
  "dir": "ltr",
  "screenshots": [
    {
      "src": "/screenshot-mobile.png",
      "sizes": "390x844",
      "type": "image/png",
      "form_factor": "narrow"
    },
    {
      "src": "/screenshot-desktop.png",
      "sizes": "1280x720",
      "type": "image/png",
      "form_factor": "wide"
    }
  ],
  "shortcuts": [
    {
      "name": "My Library",
      "url": "/library",
      "description": "View your podcast library",
      "icons": [
        {
          "src": "/icon-library.png",
          "sizes": "192x192"
        }
      ]
    },
    {
      "name": "Discover",
      "url": "/search",
      "description": "Find new podcasts",
      "icons": [
        {
          "src": "/icon-search.png",
          "sizes": "192x192"
        }
      ]
    }
  ],
  "icons": [
    {
      "src": "/icon-72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/icon-96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/icon-128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/icon-144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "/icon-152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icon-384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

## Media Session API Implementation (Phase 2)

### Background Audio Controls

```typescript
// Media Session API for background audio controls
// src/services/mediaSession.ts

export class MediaSessionService {
  private currentEpisode: Episode | null = null
  private audioElement: HTMLAudioElement | null = null

  initialize(audioElement: HTMLAudioElement) {
    this.audioElement = audioElement

    if ('mediaSession' in navigator) {
      // Set up media session handlers
      navigator.mediaSession.setActionHandler('play', () => {
        this.audioElement?.play()
      })

      navigator.mediaSession.setActionHandler('pause', () => {
        this.audioElement?.pause()
      })

      navigator.mediaSession.setActionHandler('seekbackward', details => {
        const skipTime = details.seekOffset || 15
        this.audioElement!.currentTime = Math.max(0, this.audioElement!.currentTime - skipTime)
      })

      navigator.mediaSession.setActionHandler('seekforward', details => {
        const skipTime = details.seekOffset || 15
        this.audioElement!.currentTime = Math.min(
          this.audioElement!.duration,
          this.audioElement!.currentTime + skipTime,
        )
      })

      navigator.mediaSession.setActionHandler('previoustrack', () => {
        // Navigate to previous episode
        this.playPreviousEpisode()
      })

      navigator.mediaSession.setActionHandler('nexttrack', () => {
        // Navigate to next episode
        this.playNextEpisode()
      })
    }
  }

  updateMetadata(episode: Episode, podcast: Podcast) {
    this.currentEpisode = episode

    if ('mediaSession' in navigator) {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: episode.title,
        artist: podcast.title,
        album: 'Rewind',
        artwork: [
          {
            src: episode.imageUrl || podcast.imageUrl,
            sizes: '512x512',
            type: 'image/png',
          },
        ],
      })
    }
  }

  updatePlaybackState(state: 'playing' | 'paused') {
    if ('mediaSession' in navigator) {
      navigator.mediaSession.playbackState = state
    }
  }

  updatePositionState(duration: number, position: number, playbackRate: number = 1.0) {
    if ('mediaSession' in navigator) {
      navigator.mediaSession.setPositionState({
        duration,
        position,
        playbackRate,
      })
    }
  }
}
```

### Lock Screen Integration

```typescript
// Enhanced media session with lock screen controls
// src/hooks/useMediaSession.ts

export const useMediaSession = (audioRef: React.RefObject<HTMLAudioElement>) => {
  const mediaSession = useRef(new MediaSessionService())

  useEffect(() => {
    if (audioRef.current) {
      mediaSession.current.initialize(audioRef.current)
    }
  }, [audioRef])

  const updateNowPlaying = useCallback((episode: Episode, podcast: Podcast) => {
    mediaSession.current.updateMetadata(episode, podcast)

    // Update background color based on podcast artwork
    if ('mediaSession' in navigator && episode.imageUrl) {
      extractColorsFromImage(episode.imageUrl).then(colors => {
        document.documentElement.style.setProperty('--media-theme-color', colors.primary)
      })
    }
  }, [])

  const updatePlaybackState = useCallback((isPlaying: boolean) => {
    mediaSession.current.updatePlaybackState(isPlaying ? 'playing' : 'paused')
  }, [])

  return {
    updateNowPlaying,
    updatePlaybackState,
    updatePositionState: mediaSession.current.updatePositionState.bind(mediaSession.current),
  }
}
```

## ðŸ“‹ App Installation Experience (Phase 2)

### Installation Prompts

```typescript
// App installation service
// src/services/installService.ts

export class InstallService {
  private deferredPrompt: any = null
  private installButton: HTMLElement | null = null

  initialize() {
    // Listen for beforeinstallprompt event
    window.addEventListener('beforeinstallprompt', e => {
      // Prevent automatic prompt
      e.preventDefault()
      this.deferredPrompt = e

      // Show custom install button
      this.showInstallButton()
    })

    // Listen for app installation
    window.addEventListener('appinstalled', () => {
      this.hideInstallButton()
      this.trackInstallation()
    })
  }

  async promptInstall() {
    if (this.deferredPrompt) {
      // Show the install prompt
      this.deferredPrompt.prompt()

      // Wait for user response
      const choiceResult = await this.deferredPrompt.userChoice

      if (choiceResult.outcome === 'accepted') {
        console.log('User accepted the install prompt')
      } else {
        console.log('User dismissed the install prompt')
      }

      this.deferredPrompt = null
    }
  }

  private showInstallButton() {
    // Show install button in header or as banner
    const installBanner = document.createElement('div')
    installBanner.className = 'install-banner'
    installBanner.innerHTML = `
      <div class="install-content">
        <p>Install Rewind for a better experience</p>
        <button id="install-button" class="install-btn">Install</button>
        <button id="dismiss-install" class="dismiss-btn">Ã—</button>
      </div>
    `

    document.body.appendChild(installBanner)

    document.getElementById('install-button')?.addEventListener('click', () => {
      this.promptInstall()
    })

    document.getElementById('dismiss-install')?.addEventListener('click', () => {
      this.hideInstallButton()
    })
  }

  private hideInstallButton() {
    const banner = document.querySelector('.install-banner')
    if (banner) {
      banner.remove()
    }
  }

  private trackInstallation() {
    // Track installation analytics
    if (typeof gtag !== 'undefined') {
      gtag('event', 'app_install', {
        method: 'pwa_prompt',
      })
    }
  }

  isInstalled(): boolean {
    return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true
  }
}
```

### Custom Installation UI

```typescript
// Installation banner component
// src/components/InstallBanner.tsx

export const InstallBanner: React.FC = () => {
  const [showBanner, setShowBanner] = useState(false);
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null);
  const installService = useRef(new InstallService());

  useEffect(() => {
    const handleBeforeInstallPrompt = (e: any) => {
      e.preventDefault();
      setDeferredPrompt(e);

      // Show banner after user has been active for 30 seconds
      setTimeout(() => {
        if (!installService.current.isInstalled()) {
          setShowBanner(true);
        }
      }, 30000);
    };

    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);

    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    };
  }, []);

  const handleInstall = async () => {
    if (deferredPrompt) {
      deferredPrompt.prompt();
      const choiceResult = await deferredPrompt.userChoice;

      if (choiceResult.outcome === 'accepted') {
        setShowBanner(false);
      }

      setDeferredPrompt(null);
    }
  };

  if (!showBanner || installService.current.isInstalled()) {
    return null;
  }

  return (
    <motion.div
      initial={{ y: 100, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      exit={{ y: 100, opacity: 0 }}
      className="fixed bottom-4 left-4 right-4 bg-red-500 text-white p-4 rounded-lg shadow-lg z-50"
    >
      <div className="flex items-center justify-between">
        <div>
          <h3 className="font-semibold">Install Rewind</h3>
          <p className="text-sm opacity-90">Get the full app experience</p>
        </div>
        <div className="flex gap-2">
          <button
            onClick={handleInstall}
            className="bg-white text-red-500 px-4 py-2 rounded font-medium"
          >
            Install
          </button>
          <button
            onClick={() => setShowBanner(false)}
            className="text-white opacity-75 hover:opacity-100"
          >
            Ã—
          </button>
        </div>
      </div>
    </motion.div>
  );
};
```

## ðŸ”® Push Notifications (Phase 3)

### Notification Service Setup

```typescript
// Push notification service
// src/services/notificationService.ts

export class NotificationService {
  private registration: ServiceWorkerRegistration | null = null

  async initialize() {
    if ('serviceWorker' in navigator && 'PushManager' in window) {
      this.registration = await navigator.serviceWorker.ready
    }
  }

  async requestPermission(): Promise<boolean> {
    const permission = await Notification.requestPermission()
    return permission === 'granted'
  }

  async subscribe(): Promise<PushSubscription | null> {
    if (!this.registration) return null

    try {
      const subscription = await this.registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: this.urlBase64ToUint8Array(process.env.VITE_VAPID_PUBLIC_KEY!),
      })

      // Send subscription to backend
      await this.sendSubscriptionToBackend(subscription)

      return subscription
    } catch (error) {
      console.error('Failed to subscribe to push notifications:', error)
      return null
    }
  }

  private async sendSubscriptionToBackend(subscription: PushSubscription) {
    await fetch('/api/push/subscribe', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${getAccessToken()}`,
      },
      body: JSON.stringify(subscription),
    })
  }

  private urlBase64ToUint8Array(base64String: string): Uint8Array {
    const padding = '='.repeat((4 - (base64String.length % 4)) % 4)
    const base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/')

    const rawData = window.atob(base64)
    const outputArray = new Uint8Array(rawData.length)

    for (let i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(i)
    }
    return outputArray
  }
}
```

### Notification Types

```typescript
// Notification message types
interface NewEpisodeNotification {
  type: 'new_episode'
  podcastTitle: string
  episodeTitle: string
  imageUrl: string
  actionUrl: string
}

interface RecommendationNotification {
  type: 'recommendation'
  title: string
  message: string
  episodeIds: string[]
  actionUrl: string
}

interface LibraryShareNotification {
  type: 'library_share'
  sharerName: string
  podcastCount: number
  shareId: string
}
```

## Offline Capabilities

### Current Offline Support âœ… IMPLEMENTED

- **Static Assets**: App shell, CSS, and JavaScript cached
- **Basic API Caching**: Podcast metadata cached for offline viewing
- **Fallback Pages**: Offline page when content unavailable

### Enhanced Offline Support (Phase 2)

- **Podcast Library**: Full offline access to user's podcast collection
- **Episode Metadata**: Cached episode information and descriptions
- **Search History**: Offline access to recent searches
- **User Preferences**: Cached settings and preferences

### Advanced Offline Support (Phase 3)

- **Audio Downloads**: Download episodes for offline listening
- **Intelligent Caching**: Pre-cache recommended episodes
- **Offline Queue**: Queue actions for when connection returns
- **Sync Management**: Handle conflicts when going back online

## Performance Optimization

### Current Performance âœ… IMPLEMENTED

- **Code Splitting**: Dynamic imports for route-based splitting
- **Asset Optimization**: Compressed images and minified code
- **Caching Strategy**: Efficient caching of static and dynamic content

### Performance Targets (Phase 2)

- **First Contentful Paint**: < 1.5s on 3G
- **Largest Contentful Paint**: < 2.5s on 3G
- **Time to Interactive**: < 3.0s on 3G
- **Cumulative Layout Shift**: < 0.1

### Performance Monitoring

```typescript
// Performance monitoring setup
// src/utils/performance.ts

export const initPerformanceMonitoring = () => {
  // Monitor Core Web Vitals
  if ('PerformanceObserver' in window) {
    // Largest Contentful Paint
    new PerformanceObserver(list => {
      for (const entry of list.getEntries()) {
        console.log('LCP:', entry.startTime)
        // Send to analytics
      }
    }).observe({ entryTypes: ['largest-contentful-paint'] })

    // First Input Delay
    new PerformanceObserver(list => {
      for (const entry of list.getEntries()) {
        console.log('FID:', entry.processingStart - entry.startTime)
        // Send to analytics
      }
    }).observe({ entryTypes: ['first-input'] })
  }

  // Custom performance marks
  performance.mark('app-start')

  window.addEventListener('load', () => {
    performance.mark('app-loaded')
    performance.measure('app-load-time', 'app-start', 'app-loaded')
  })
}
```

## Testing Strategy

### PWA Testing Checklist

- **Manifest Validation**: Validate app manifest with Lighthouse
- **Service Worker**: Test caching strategies and offline functionality
- **Installation**: Test app installation flow on different devices
- **Media Session**: Verify background audio controls work correctly
- **Performance**: Regular Lighthouse audits for PWA score
- **Cross-browser**: Test PWA features across different browsers

### Automated Testing

```typescript
// PWA feature tests
// src/tests/pwa.test.ts

describe('PWA Features', () => {
  it('should register service worker', async () => {
    const registration = await navigator.serviceWorker.ready
    expect(registration).toBeDefined()
  })

  it('should cache critical resources', async () => {
    const cache = await caches.open('app-shell')
    const cachedResponse = await cache.match('/')
    expect(cachedResponse).toBeDefined()
  })

  it('should work offline', async () => {
    // Simulate offline
    await page.setOfflineMode(true)

    const response = await page.goto('/library')
    expect(response?.status()).toBe(200)
  })

  it('should show install prompt', async () => {
    // Mock beforeinstallprompt event
    await page.evaluate(() => {
      window.dispatchEvent(new Event('beforeinstallprompt'))
    })

    const installButton = await page.waitForSelector('.install-banner')
    expect(installButton).toBeTruthy()
  })
})
```

## Implementation Roadmap

### Phase 2 - Enhanced PWA (Next Sprint)

1. **Advanced Service Worker**: Enhanced caching and offline support
2. **Media Session API**: Background audio controls and lock screen integration
3. **App Installation**: Custom installation prompts and onboarding
4. **Performance Optimization**: Achieve target Core Web Vitals scores

### Phase 3 - Advanced Features (Future)

1. **Push Notifications**: New episode and recommendation notifications
2. **Background Sync**: Automatic podcast updates when connection restored
3. **Audio Downloads**: Offline episode download and management
4. **App Shortcuts**: Quick actions from home screen

### Phase 4 - Platform Integration (Future)

1. **Share Target API**: Receive shared podcast URLs from other apps
2. **File System API**: Local file management for downloaded episodes
3. **Web Locks API**: Prevent concurrent audio playback
4. **Payment Request API**: Premium subscription management

## Platform-Specific Considerations

### iOS Safari

- **Add to Home Screen**: Custom prompt for iOS users
- **Status Bar**: Proper status bar styling for PWA
- **Safe Areas**: Handle notch and home indicator properly
- **Audio Limitations**: Handle iOS audio restrictions

### Android Chrome

- **WebAPK**: Enhanced installation experience
- **Notification Icons**: Proper icon sizing for notifications
- **Share Target**: Integration with Android sharing system
- **Background Sync**: Enhanced offline capabilities

### Desktop

- **Window Controls**: Proper titlebar and window controls
- **Keyboard Shortcuts**: Desktop-specific keyboard navigation
- **Multiple Windows**: Support for multiple app instances
- **System Integration**: Dock/taskbar integration

## Notes for Implementation

### AI Agent Guidelines

- Start with basic PWA features and progressively enhance
- Test installation experience on multiple devices and browsers
- Ensure offline functionality doesn't break core features
- Monitor performance impact of PWA features
- Follow web platform best practices for PWA implementation

### Development Priorities

1. **Core PWA**: Ensure basic PWA requirements are met
2. **Installation**: Smooth app installation experience
3. **Offline**: Reliable offline functionality for core features
4. **Performance**: Maintain fast loading times
5. **Audio**: Background playback and media controls

## References

- [UI_TECH.md](./UI_TECH.md): Frontend implementation details
- [BACKEND_API.md](./BACKEND_API.md): API integration for offline support
- [INFRASTRUCTURE.md](./INFRASTRUCTURE.md): CDN and caching strategies
- [PLAN.md](./PLAN.md): Implementation timeline and priorities
- [UI_DESIGN.md](./UI_DESIGN.md): Mobile-first design specifications
